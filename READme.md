##  Сборка и запуск приложения:
В проекте используется Make все команды можно посмотреть 
```shell
  make help 
```
## Рекомендуемая команда при первом запуске:
```shell
   make start
```

## Опционально:

### Команда бля билда докер образа:
```shell
  make build
```
### Команда для поднятия контейнеров в дев режиме
```shell
  make up
```

#### Важно добавить в **etc/hosts** строчку
```
127.0.0.1   backend.app.loc
```

## Приложение будет доступно по адресу (если вы следовали инструкции):
### [backend.app.loc](http://backend.app.loc)

## Если зашли на http://backend.app.loc и вас редиректнуло на гифку значит бекенд работает)

и на 80 порту (точнее его будет проксировать Nginx) и на порту 8080 (сам контейнер приложения)
(*важно чтобы у вас ничего другого не крутилось в фоновом режиме на этих портах)
Redis будет крутиться в network приложения и он будет доступен по redis:6379

## Основные компоненты:
1. Само приложение на Go:
   * Go 1.22
   * Gin  HTTP-веб-фреймворк
2. Redis — резидентная система управления базами данных класса NoSQL, работающая со структурами данных типа «ключ — значение».
3. Nginx - в качестве прокси-сервера
4. Docker и Docker-Compose  для разработки, доставки и запуска приложения в изолированном контейнере.

# ТЗ:
## # BackEnd

### Внешние API

Main ⇒ https://jsonplaceholder.typicode.com

Статьи ⇒ https://jsonplaceholder.typicode.com/posts

Пользователи/Авторы ⇒ https://jsonplaceholder.typicode.com/users

### Внутренний API

- [GET]: Список статей
   - без фильтров (по сути прокси, кэш 2 минуты)
   - фильтр по автору (кэш 2 минуты)
   - фильтр по просмотренным статьям пользователя (кэша нет, получение просмотренных статей пользователя, по uuid пользователя (при отсутствии uuid выдавать ошибку 404))
- [GET]: Детальная статья (кэш 5 минут)
- [GET]: Список авторов (кэш 5 минут)
- [POST]: Запись просмотренной статьи (учесть возможность XSS и SQL инъекции, а также массовую отправку запросов, например добавив “капчу v3”),  путем привязки id статьи к uuid пользователя, если его нет в бд, то создаем и привязываем id статьи.

Примечание:

- В рамках данной реализации пользователя помним по сгенерированному UUID, который храним в cookie с флагом httpOnly
- При запросе внутри Nuxt 3, проверяем наличие cookie c флагом httpOnly. Если ее нет, Создание пользователя (например на уровне middleware, механизм следующий: путем генерации UUID и установки cookie с флагом httpOnly в браузере)